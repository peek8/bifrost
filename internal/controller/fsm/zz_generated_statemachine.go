// This file is generated by VectorSigma v1.1.0-6-g51bdd41 (commit: 51bdd41, built at: 2025-11-25T08:38:27Z.1.0). DO NOT EDIT.
package fsm

import (
	"errors"
	"fmt"

	ctrl "sigs.k8s.io/controller-runtime"
)

type (
	StateName  string
	ActionName string
	GuardName  string
)

const (
	AllComponentsDone           StateName = "AllComponentsDone"
	BuildingStatus              StateName = "BuildingStatus"
	ClearUnnecessaryErrors      StateName = "ClearUnnecessaryErrors"
	Closing                     StateName = "Closing"
	ClosingInitial              StateName = "ClosingInitial"
	CollectingStatusInformation StateName = "CollectingStatusInformation"
	CreatingComponent           StateName = "CreatingComponent"
	EditMande                   StateName = "EditMande"
	EndingWave                  StateName = "EndingWave"
	FinalState                  StateName = "FinalState"
	GeneratingAlloyComponents   StateName = "GeneratingAlloyComponents"
	GeneratingGrafanaComponents StateName = "GeneratingGrafanaComponents"
	GeneratingLokiComponents    StateName = "GeneratingLokiComponents"
	HandlingError               StateName = "HandlingError"
	HandlingSuccess             StateName = "HandlingSuccess"
	ImmediateReconcile          StateName = "ImmediateReconcile"
	InitialState                StateName = "InitialState"
	Initializing                StateName = "Initializing"
	InitializingContext         StateName = "InitializingContext"
	InitializingWave            StateName = "InitializingWave"
	ItemsNotReady               StateName = "ItemsNotReady"
	LoadingComponent            StateName = "LoadingComponent"
	LoadingSubject              StateName = "LoadingSubject"
	NotDone                     StateName = "NotDone"
	PickingNextComponent        StateName = "PickingNextComponent"
	PlanDefaultReconcile        StateName = "PlanDefaultReconcile"
	ProcessingComponent         StateName = "ProcessingComponent"
	SendingEvent                StateName = "SendingEvent"
	SubjectDoesNotExist         StateName = "SubjectDoesNotExist"
	SyncingWave                 StateName = "SyncingWave"
	UpdatingComponent           StateName = "UpdatingComponent"
	UpdatingStatus              StateName = "UpdatingStatus"
)

const (
	ClearCondition                 ActionName = "ClearCondition"
	ClearError                     ActionName = "ClearError"
	CollectCommonStatusInformation ActionName = "CollectCommonStatusInformation"
	CollectStatusInformation       ActionName = "CollectStatusInformation"
	CreateComponent                ActionName = "CreateComponent"
	DoneWithComponent              ActionName = "DoneWithComponent"
	GenerateAlloyConfig            ActionName = "GenerateAlloyConfig"
	GenerateAlloyRbac              ActionName = "GenerateAlloyRbac"
	GenerateAlloyStorage           ActionName = "GenerateAlloyStorage"
	GenerateAlloyWorkloads         ActionName = "GenerateAlloyWorkloads"
	GenerateGrafanaConfig          ActionName = "GenerateGrafanaConfig"
	GenerateGrafanaStorage         ActionName = "GenerateGrafanaStorage"
	GenerateGrafanaWorkloads       ActionName = "GenerateGrafanaWorkloads"
	GenerateLokiConfig             ActionName = "GenerateLokiConfig"
	GenerateLokiStorage            ActionName = "GenerateLokiStorage"
	GenerateLokiWorkloads          ActionName = "GenerateLokiWorkloads"
	InitializeContext              ActionName = "InitializeContext"
	InitializeWave                 ActionName = "InitializeWave"
	LoadComponent                  ActionName = "LoadComponent"
	LoadSubject                    ActionName = "LoadSubject"
	PickNextComponent              ActionName = "PickNextComponent"
	RaiseCondition                 ActionName = "RaiseCondition"
	ReconcileIn                    ActionName = "ReconcileIn"
	SendEvent                      ActionName = "SendEvent"
	SetFlag                        ActionName = "SetFlag"
	SetPhase                       ActionName = "SetPhase"
	SetWave                        ActionName = "SetWave"
	UpdateComponent                ActionName = "UpdateComponent"
	UpdateStatus                   ActionName = "UpdateStatus"
)

const (
	ComponentDiffers           GuardName = "ComponentDiffers"
	ComponentDoesNotExist      GuardName = "ComponentDoesNotExist"
	Dirty                      GuardName = "Dirty"
	HasFlag                    GuardName = "HasFlag"
	IsError                    GuardName = "IsError"
	MissingFlag                GuardName = "MissingFlag"
	MoreComponents             GuardName = "MoreComponents"
	ObservedComponentsNotReady GuardName = "ObservedComponentsNotReady"
	ReconcileNotPlanned        GuardName = "ReconcileNotPlanned"
	WasWave                    GuardName = "WasWave"
	WaveNotDone                GuardName = "WaveNotDone"
)

const maxStateDepth = 5

// Action represents a function that can be executed in a state and may return an error.
type Action struct {
	Name    ActionName
	Params  []string
	Execute func(...string) error
}

// Guard represents a function that returns a boolean indicating if a transition should occur.
type Guard struct {
	Name   GuardName
	Params []string
	Check  func(...string) bool
	Action *Action
}

// StateConfig holds the actions and guards for a state.
type StateConfig struct {
	Actions     []Action
	Guards      []Guard
	Transitions map[int]StateName // Maps guard index to the next state
	Composite   CompositeState
}

type CompositeState struct {
	InitialState StateName
	StateConfigs map[StateName]StateConfig
}

// VectorSigma represents the Finite State Machine (fsm) for VectorSigma.
type BifrostOperator struct {
	Context       *Context
	CurrentState  StateName
	ExtendedState *ExtendedState
	StateConfigs  map[StateName]StateConfig
}

// New initializes a new FSM.
func New() *BifrostOperator {
	fsm := &BifrostOperator{
		Context:       &Context{},
		CurrentState:  InitialState,
		ExtendedState: &ExtendedState{},
		StateConfigs:  make(map[StateName]StateConfig),
	}
	fsm.StateConfigs[BuildingStatus] = StateConfig{
		Actions: []Action{},
		Guards:  []Guard{},
		Transitions: map[int]StateName{
			0: Closing,
		},
		Composite: CompositeState{
			InitialState: InitialState,
			StateConfigs: map[StateName]StateConfig{
				AllComponentsDone: {
					Actions: []Action{
						{Name: SetPhase, Execute: fsm.SetPhaseAction, Params: []string{"Ready"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},
				CollectingStatusInformation: {
					Actions: []Action{
						{Name: CollectCommonStatusInformation, Execute: fsm.CollectCommonStatusInformationAction, Params: []string{}},
						{Name: CollectStatusInformation, Execute: fsm.CollectStatusInformationAction, Params: []string{}},
					},
					Guards: []Guard{
						{Name: HasFlag, Params: []string{"NeedsReconcile"}, Check: fsm.HasFlagGuard},
						{Name: ObservedComponentsNotReady, Params: []string{}, Check: fsm.ObservedComponentsNotReadyGuard},
						{Name: WaveNotDone, Params: []string{}, Check: fsm.WaveNotDoneGuard},
					},
					Transitions: map[int]StateName{
						0: EditMande,
						1: ItemsNotReady,
						2: NotDone,
						3: AllComponentsDone,
					},
				},
				EditMande: {
					Actions: []Action{
						{Name: SetPhase, Execute: fsm.SetPhaseAction, Params: []string{"Pending/Updated"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},

				InitialState: {
					Actions: []Action{},
					Guards:  []Guard{},
					Transitions: map[int]StateName{
						0: CollectingStatusInformation,
					},
				},
				ItemsNotReady: {
					Actions: []Action{
						{Name: SetPhase, Execute: fsm.SetPhaseAction, Params: []string{"Pending/ComponentNotHealthy"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},
				NotDone: {
					Actions: []Action{
						{Name: SetPhase, Execute: fsm.SetPhaseAction, Params: []string{"Pending"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},
			},
		},
	}
	fsm.StateConfigs[Closing] = StateConfig{
		Actions: []Action{},
		Guards:  []Guard{},
		Transitions: map[int]StateName{
			0: FinalState,
		},
		Composite: CompositeState{
			InitialState: InitialState,
			StateConfigs: map[StateName]StateConfig{
				ClearUnnecessaryErrors: {
					Actions: []Action{
						{Name: ClearError, Execute: fsm.ClearErrorAction, Params: []string{}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: SendingEvent,
					},
				},
				ClosingInitial: {
					Actions: []Action{},
					Guards: []Guard{
						{Name: IsError, Params: []string{}, Check: fsm.IsErrorGuard},
						{Name: HasFlag, Params: []string{"NeedsReconcile"}, Check: fsm.HasFlagGuard},
					},
					Transitions: map[int]StateName{
						0: HandlingError,
						1: ImmediateReconcile,
						2: HandlingSuccess,
					},
				},

				HandlingError: {
					Actions: []Action{
						{Name: RaiseCondition, Execute: fsm.RaiseConditionAction, Params: []string{"Failed"}},
						{Name: SetPhase, Execute: fsm.SetPhaseAction, Params: []string{"Error"}},
					},
					Guards: []Guard{
						{Name: Dirty, Params: []string{}, Check: fsm.DirtyGuard},
					},
					Transitions: map[int]StateName{
						0: UpdatingStatus,
						1: SendingEvent,
					},
				},
				HandlingSuccess: {
					Actions: []Action{
						{Name: ClearCondition, Execute: fsm.ClearConditionAction, Params: []string{"Failed"}},
					},
					Guards: []Guard{
						{Name: Dirty, Params: []string{}, Check: fsm.DirtyGuard},
					},
					Transitions: map[int]StateName{
						0: UpdatingStatus,
						1: SendingEvent,
					},
				},
				ImmediateReconcile: {
					Actions: []Action{
						{Name: ReconcileIn, Execute: fsm.ReconcileInAction, Params: []string{"50ms"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: HandlingSuccess,
					},
				},
				InitialState: {
					Actions: []Action{},
					Guards:  []Guard{},
					Transitions: map[int]StateName{
						0: ClosingInitial,
					},
				},
				PlanDefaultReconcile: {
					Actions: []Action{
						{Name: ReconcileIn, Execute: fsm.ReconcileInAction, Params: []string{"5m"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},
				SendingEvent: {
					Actions: []Action{
						{Name: SendEvent, Execute: fsm.SendEventAction, Params: []string{}},
					},
					Guards: []Guard{
						{Name: ReconcileNotPlanned, Params: []string{}, Check: fsm.ReconcileNotPlannedGuard},
					},
					Transitions: map[int]StateName{
						0: PlanDefaultReconcile,
						1: FinalState,
					},
				},
				UpdatingStatus: {
					Actions: []Action{
						{Name: UpdateStatus, Execute: fsm.UpdateStatusAction, Params: []string{}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: SendingEvent,
					},
				},
			},
		},
	}
	fsm.StateConfigs[EndingWave] = StateConfig{
		Actions: []Action{
			{Name: SetWave, Execute: fsm.SetWaveAction, Params: []string{"Done"}},
		},
		Guards: []Guard{},
		Transitions: map[int]StateName{
			0: BuildingStatus,
		},
	}

	fsm.StateConfigs[GeneratingAlloyComponents] = StateConfig{
		Actions: []Action{
			{Name: GenerateAlloyStorage, Execute: fsm.GenerateAlloyStorageAction, Params: []string{}},
			{Name: GenerateAlloyRbac, Execute: fsm.GenerateAlloyRbacAction, Params: []string{}},
			{Name: GenerateAlloyConfig, Execute: fsm.GenerateAlloyConfigAction, Params: []string{}},
			{Name: GenerateAlloyWorkloads, Execute: fsm.GenerateAlloyWorkloadsAction, Params: []string{}},
			{Name: SetWave, Execute: fsm.SetWaveAction, Params: []string{"Alloy"}},
		},
		Guards: []Guard{
			{Name: IsError, Params: []string{}, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: Closing,
			1: SyncingWave,
		},
	}
	fsm.StateConfigs[GeneratingGrafanaComponents] = StateConfig{
		Actions: []Action{
			{Name: GenerateGrafanaStorage, Execute: fsm.GenerateGrafanaStorageAction, Params: []string{}},
			{Name: GenerateGrafanaConfig, Execute: fsm.GenerateGrafanaConfigAction, Params: []string{}},
			{Name: GenerateGrafanaWorkloads, Execute: fsm.GenerateGrafanaWorkloadsAction, Params: []string{}},
			{Name: SetWave, Execute: fsm.SetWaveAction, Params: []string{"Grafana"}},
		},
		Guards: []Guard{
			{Name: IsError, Params: []string{}, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: Closing,
			1: SyncingWave,
		},
	}
	fsm.StateConfigs[GeneratingLokiComponents] = StateConfig{
		Actions: []Action{
			{Name: GenerateLokiStorage, Execute: fsm.GenerateLokiStorageAction, Params: []string{}},
			{Name: GenerateLokiConfig, Execute: fsm.GenerateLokiConfigAction, Params: []string{}},
			{Name: GenerateLokiWorkloads, Execute: fsm.GenerateLokiWorkloadsAction, Params: []string{}},
			{Name: SetWave, Execute: fsm.SetWaveAction, Params: []string{"Loki"}},
		},
		Guards: []Guard{
			{Name: IsError, Params: []string{}, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: Closing,
			1: SyncingWave,
		},
	}
	fsm.StateConfigs[InitialState] = StateConfig{
		Actions: []Action{},
		Guards:  []Guard{},
		Transitions: map[int]StateName{
			0: Initializing,
		},
	}
	fsm.StateConfigs[Initializing] = StateConfig{
		Actions: []Action{},
		Guards: []Guard{
			{Name: IsError, Params: []string{}, Check: fsm.IsErrorGuard},
			{Name: MissingFlag, Params: []string{"SubjectLoaded"}, Check: fsm.MissingFlagGuard},
		},
		Transitions: map[int]StateName{
			0: FinalState,
			1: FinalState,
			2: GeneratingAlloyComponents,
		},
		Composite: CompositeState{
			InitialState: InitialState,
			StateConfigs: map[StateName]StateConfig{

				InitialState: {
					Actions: []Action{},
					Guards:  []Guard{},
					Transitions: map[int]StateName{
						0: InitializingContext,
					},
				},
				InitializingContext: {
					Actions: []Action{
						{Name: InitializeContext, Execute: fsm.InitializeContextAction, Params: []string{}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: LoadingSubject,
					},
				},
				LoadingSubject: {
					Actions: []Action{
						{Name: LoadSubject, Execute: fsm.LoadSubjectAction, Params: []string{}},
						{Name: SetFlag, Execute: fsm.SetFlagAction, Params: []string{"SubjectLoaded"}},
					},
					Guards: []Guard{
						{Name: IsError, Params: []string{"K8s:NotFound"}, Check: fsm.IsErrorGuard},
					},
					Transitions: map[int]StateName{
						0: SubjectDoesNotExist,
						1: FinalState,
					},
				},
				SubjectDoesNotExist: {
					Actions: []Action{
						{Name: ClearError, Execute: fsm.ClearErrorAction, Params: []string{}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},
			},
		},
	}
	fsm.StateConfigs[PickingNextComponent] = StateConfig{
		Actions:     []Action{},
		Guards:      []Guard{},
		Transitions: map[int]StateName{},
	}
	fsm.StateConfigs[ProcessingComponent] = StateConfig{
		Actions: []Action{},
		Guards:  []Guard{},
		Transitions: map[int]StateName{
			0: PickingNextComponent,
		},
	}
	fsm.StateConfigs[SyncingWave] = StateConfig{
		Actions: []Action{},
		Guards: []Guard{
			{Name: WasWave, Params: []string{"Alloy"}, Check: fsm.WasWaveGuard},
			{Name: WasWave, Params: []string{"Loki"}, Check: fsm.WasWaveGuard},
			{Name: IsError, Params: []string{}, Check: fsm.IsErrorGuard},
		},
		Transitions: map[int]StateName{
			0: GeneratingLokiComponents,
			1: GeneratingGrafanaComponents,
			2: EndingWave,
			3: Closing,
		},
		Composite: CompositeState{
			InitialState: InitialState,
			StateConfigs: map[StateName]StateConfig{
				CreatingComponent: {
					Actions: []Action{
						{Name: CreateComponent, Execute: fsm.CreateComponentAction, Params: []string{}},
						{Name: SetFlag, Execute: fsm.SetFlagAction, Params: []string{"NeedsReconcile"}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},

				InitialState: {
					Actions: []Action{},
					Guards:  []Guard{},
					Transitions: map[int]StateName{
						0: InitializingWave,
						1: LoadingComponent,
					},
				},
				InitializingWave: {
					Actions: []Action{
						{Name: InitializeWave, Execute: fsm.InitializeWaveAction, Params: []string{}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: PickingNextComponent,
					},
				},
				LoadingComponent: {
					Actions: []Action{
						{Name: LoadComponent, Execute: fsm.LoadComponentAction, Params: []string{}},
					},
					Guards: []Guard{
						{Name: ComponentDoesNotExist, Params: []string{}, Check: fsm.ComponentDoesNotExistGuard},
						{Name: ComponentDiffers, Params: []string{}, Check: fsm.ComponentDiffersGuard},
					},
					Transitions: map[int]StateName{
						0: CreatingComponent,
						1: UpdatingComponent,
						2: FinalState,
					},
				},
				PickingNextComponent: {
					Actions: []Action{
						{Name: PickNextComponent, Execute: fsm.PickNextComponentAction, Params: []string{}},
					},
					Guards: []Guard{
						{Name: MoreComponents, Params: []string{}, Check: fsm.MoreComponentsGuard},
					},
					Transitions: map[int]StateName{
						0: ProcessingComponent,
						1: FinalState,
					},
				},
				ProcessingComponent: {
					Actions:     []Action{},
					Guards:      []Guard{},
					Transitions: map[int]StateName{},
				},
				UpdatingComponent: {
					Actions: []Action{
						{Name: UpdateComponent, Execute: fsm.UpdateComponentAction, Params: []string{}},
						{Name: SetFlag, Execute: fsm.SetFlagAction, Params: []string{"NeedsReconcile"}},
						{Name: DoneWithComponent, Execute: fsm.DoneWithComponentAction, Params: []string{}},
					},
					Guards: []Guard{},
					Transitions: map[int]StateName{
						0: FinalState,
					},
				},
			},
		},
	}

	return fsm
}

// Run handles the state transitions based on the current state.
func (fsm *BifrostOperator) Run() (ctrl.Result, error) {
	return run(fsm, fsm.StateConfigs, 0)
}

func run(fsm *BifrostOperator, stateConfigs map[StateName]StateConfig, depth int) (ctrl.Result, error) {
	if depth > maxStateDepth {
		return ctrl.Result{}, fmt.Errorf("max state depth exceeded")
	}

	for {
		// If we are in the FinalState, exit the FSM
		if fsm.CurrentState == FinalState {
			// Reset to the Initial State in case the FSM is run in a loop
			fsm.CurrentState = InitialState

			return fsm.ExtendedState.Result, fsm.ExtendedState.Error
		}

		config, exists := stateConfigs[fsm.CurrentState]

		if !exists {
			err := errors.New("missing state config for " + string(fsm.CurrentState))
			fsm.Context.Logger.Error(err, "missing config", "state", fsm.CurrentState)

			return ctrl.Result{}, err
		}

		if config.Composite.StateConfigs != nil {
			parentState := fsm.CurrentState
			// Recursively run the composite state machine
			fsm.CurrentState = config.Composite.InitialState
			fsm.Context.Logger.V(1).Info("entering composite state", "state", parentState, "initial", fsm.CurrentState)
			_, err := run(fsm, config.Composite.StateConfigs, depth+1)
			if err != nil {
				fsm.Context.Logger.Error(err, "composite state machine failed", "state", fsm.CurrentState)
				fsm.ExtendedState.Error = err
			}

			fsm.Context.Logger.V(1).Info("exiting composite state", "state", parentState)
			fsm.CurrentState = parentState
		} else {
			// Execute all actions for the current state
			err := runAllActions(fsm.Context, fsm.CurrentState, config.Actions)
			if err != nil {
				fsm.Context.Logger.Error(err, "action failed", "state", fsm.CurrentState)
				fsm.ExtendedState.Error = err
			}
		}

		// Check guards and determine the next state
		nextState, err := runAllGuards(fsm.Context, fsm.CurrentState, config)
		if err != nil {
			// Guarded actions will always transition to the FinalState
			fsm.ExtendedState.Error = err
			fsm.CurrentState = FinalState
		}
		if nextState != "" {
			fsm.CurrentState = nextState

			continue
		}

		// Check for unguarded transition
		if nextState, exists := config.Transitions[len(config.Guards)]; exists {
			fsm.Context.Logger.V(1).Info("unguarded transition", "current", fsm.CurrentState, "next", nextState)
			fsm.CurrentState = nextState
		}
	}
}

func runAllActions(context *Context, currentState StateName, actions []Action) error {
	for _, action := range actions {
		context.Logger.V(1).Info("executing", "action", action.Name, "state", currentState)

		if err := action.Execute(action.Params...); err != nil {
			return err
		}
	}

	return nil
}

func runAllGuards(context *Context, currentState StateName, config StateConfig) (StateName, error) {
	for guardIndex, guard := range config.Guards {
		if guard.Check(guard.Params...) {
			if guard.Action != nil {
				action := guard.Action
				if err := action.Execute(action.Params...); err != nil {
					context.Logger.V(1).Info("guarded action failed", "state", currentState,
						"guard", guard.Name, "action", action.Name, "error", err)

					return "", err
				}
			}

			// Transition to the state mapped to this guard index
			if nextState, exists := config.Transitions[guardIndex]; exists {
				context.Logger.V(1).Info("guarded transition", "guard", guard.Name, "current", currentState, "next", nextState)

				return nextState, nil
			}
		}
	}

	return "", nil
}
